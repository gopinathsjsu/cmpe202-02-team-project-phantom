services:
  # Note: MongoDB and PostgreSQL are cloud-hosted (MongoDB Atlas and Neon)
  # Services connect via DATABASE_URL, CHAT_MONGO_URI, and MONGO_URI environment variables
  # No local database containers needed

  rabbitmq:
    image: rabbitmq:3-management
    healthcheck:
      test: ["CMD", "rabbitmqctl", "status"]
      interval: 5s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    command: ["redis-server", "--appendonly", "no"]
    ports: ["6379:6379"]


  listing-service:
    build: 
      context: .
      dockerfile: ./listing-service/Dockerfile
    container_name: listing-service
    env_file:
      - ./listing-service/.env
    environment:
      # DATABASE_URL can be overridden from root .env
      DATABASE_URL: ${DATABASE_URL}
      # LISTING_PORT is loaded from listing-service/.env via env_file (listing-service/.env has LISTING_PORT=8081)
    ports:
      # LISTING_PORT from root .env file (for docker-compose port mapping)
      # Root .env should have LISTING_PORT=8081 (matches listing-service/.env)
      # Falls back to default 8081 if not set
      - "${LISTING_PORT:-8081}:${LISTING_PORT:-8081}"
    # No longer depends on db-seeder / local Postgres


  orchestrator:
    build: 
      context: .
      dockerfile: ./orchestrator/Dockerfile
    container_name: orchestrator
    env_file:
      - ./orchestrator/.env
    ports:
      # PORT from root .env file (for docker-compose port mapping)
      # Root .env should have PORT=8080 (matches orchestrator/.env)
      # Falls back to default 8080 if not set
      - "${PORT:-8080}:${PORT:-8080}"
    environment:
      # DATABASE_URL is loaded from orchestrator/.env via env_file (don't override it)
      # Override RabbitMQ URL to use Docker service name instead of localhost
      RABBITMQ_URL: amqp://guest:guest@rabbitmq:5672/
      LISTING_SERVICE_URL: http://listing-service:8081
    depends_on:
      rabbitmq:
        condition: service_healthy


  events-server:
    build:
      context: .
      dockerfile: ./events-server/Dockerfile
    container_name: events-server
    env_file:
      - ./events-server/.env
    environment:
      # Override RabbitMQ and Redis URLs to use Docker service names instead of localhost
      RABBITMQ_URL: amqp://guest:guest@rabbitmq:5672/
      REDIS_ADDR: redis:6379
      # Override orchestrator URL to use Docker service name
      ORCH_BASE_URL: http://orchestrator:8080
    ports:
      # EVENTS_PORT from root .env file (for docker-compose port mapping)
      # Root .env should have EVENTS_PORT=8001 (numeric part of PORT=:8001 in events-server/.env)
      # Falls back to default 8001 if not set
      - "${EVENTS_PORT:-8001}:${EVENTS_PORT:-8001}"
    depends_on:
      - redis
      - rabbitmq
      - orchestrator
    healthcheck:
      # No /health route shown, so do a TCP check
      # PORT format is ":8001", so we extract the number part
      test: ["CMD", "sh", "-c", "nc -z localhost $${PORT#:}"]
      interval: 10s
      timeout: 5s
      retries: 5

  chat-consumer:                # background worker
    build:
      context: .
      dockerfile: ./chat-consumer/Dockerfile
    env_file:
      - ./chat-consumer/.env
    environment:
      # Override RabbitMQ and Redis URLs to use Docker service names instead of localhost
      RABBITMQ_URL: amqp://guest:guest@rabbitmq:5672/
      REDIS_ADDR: redis:6379
    depends_on:
      rabbitmq:
        condition: service_healthy
    restart: unless-stopped      # typical for background jobs

  # Frontend runs locally (not in Docker) and connects to backend services via localhost
  # Backend services expose ports to localhost, so frontend uses:
  # - NEXT_PUBLIC_ORCHESTRATOR_URL=http://localhost:8080
  # - NEXT_PUBLIC_EVENTS_SERVER_URL=ws://localhost:8001/ws
  # See frontend/.env for configuration

# Note: No database volumes needed - using cloud-hosted databases (Neon PostgreSQL and MongoDB Atlas)
# All databases are accessed via connection URIs in service .env files
