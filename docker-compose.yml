services:
  # ------------------------------------------------------------------
  # OPTIONAL: Local Postgres + seeder (NOT used when connecting to Neon)
  # ------------------------------------------------------------------
  # db:
  #   container_name: db
  #   image: postgres:16
  #   restart: unless-stopped
  #   env_file: .env
  #   environment:
  #     POSTGRES_USER: ${DB_USER}
  #     POSTGRES_PASSWORD: ${DB_PASSWORD}
  #     POSTGRES_DB: ${DB_NAME}
  #   ports:
  #     - "${DB_PORT}:${DB_PORT}"
  #   volumes:
  #     - pgdata:/var/lib/postgresql/data
  #   healthcheck:
  #     test: ["CMD-SHELL", "pg_isready -U $${POSTGRES_USER} -d $${POSTGRES_DB}"]
  #     interval: 3s
  #     timeout: 3s
  #     retries: 20
  # 
  # db-seeder:
  #   image: postgres:16
  #   depends_on:
  #     db:
  #       condition: service_healthy
  #   volumes:
  #     - ./database:/seed
  #   env_file:
  #     - .env
  #   command: >
  #     bash -lc "
  #       echo 'Waiting for Postgres: ';
  #       echo $$DB_NAME;
  #       until pg_isready -h $$DB_HOST -U $$DB_USER -d $$DB_NAME; do sleep 1; done;
  #       export PGPASSWORD=\"$$DB_PASSWORD\";
  #       echo 'Running SQL seed files.';
  #       for f in ./seed/*.sql; do
  #         echo 'Executing' $$f;
  #         psql -h $$DB_HOST -U $$DB_USER -d $$DB_NAME -v ON_ERROR_STOP=1 -1 -f \"$$f\";
  #       done;
  #       echo 'All seed files executed successfully.';
  #     "

  # ------------------------------------------------------------------
  # OPTIONAL: Local MongoDB (NOT used when connecting to MongoDB Atlas)
  # ------------------------------------------------------------------
  # mongo:
  #   image: mongo:7
  #   healthcheck:
  #     test: ["CMD", "mongosh", "--eval", "db.adminCommand('ping')"]
  #     interval: 5s
  #     timeout: 5s
  #     retries: 5

  rabbitmq:
    image: rabbitmq:3-management
    healthcheck:
      test: ["CMD", "rabbitmqctl", "status"]
      interval: 5s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    command: ["redis-server", "--appendonly", "no"]
    ports: ["6379:6379"]


  listing-service:
    image: danlamgcm/listing-service:latest
    build: 
      context: .
      dockerfile: ./listing-service/Dockerfile
    container_name: listing-service
    env_file:
      - ./.env
    environment:
      # This will come from your .env and should point to Neon
      DATABASE_URL: ${DATABASE_URL}
    ports:
      - "${LISTING_PORT}:${LISTING_PORT}"
    # No longer depends on db-seeder / local Postgres


  orchestrator:
    image: danlamgcm/orchestrator:latest
    build: 
      context: .
      dockerfile: ./orchestrator/Dockerfile
    container_name: orchestrator
    env_file:
      - ./.env
    ports:
      - "${ORCHESTRATOR_PORT}:${ORCHESTRATOR_PORT}"
    environment:
      # Use a single DATABASE_URL from .env (Neon)
      DATABASE_URL: ${DATABASE_URL}
      # MongoDB Atlas connection string (optional)
      # Format: mongodb+srv://username:password@cluster.mongodb.net/chatdb?retryWrites=true&w=majority
      # Set CHAT_MONGO_URI in .env file to your MongoDB Atlas connection string
      CHAT_MONGO_URI: ${CHAT_MONGO_URI}
      # RabbitMQ connection using Docker service name
      RABBITMQ_URL: ${RABBITMQ_URL:-amqp://guest:guest@rabbitmq:5672/}
      RABBITMQ_QUEUE_NAME: ${RABBITMQ_QUEUE_NAME:-chat_messages}
      # Listing service connection using Docker service name
      LISTING_SERVICE_URL: ${LISTING_SERVICE_URL:-http://listing-service:${LISTING_PORT:-8080}}
      LISTING_SERVICE_SHARED_SECRET: ${LISTING_SERVICE_SHARED_SECRET}
      # CORS allowed origins (comma-separated list)
      # Should include your frontend URL (e.g., http://3.17.68.221:3000 or https://yourdomain.com)
      CORS_ALLOWED_ORIGINS: ${CORS_ALLOWED_ORIGINS:-http://localhost:3000,http://localhost:3001}
    depends_on:
      rabbitmq:
        condition: service_healthy
      listing-service:
        condition: service_started


  events-server:
    image: danlamgcm/events-server:latest
    build:
      context: .
      dockerfile: ./events-server/Dockerfile
    container_name: events-server
    env_file:
      - ./.env
    environment:
      # Server
      PORT: ":8001"
      # Orchestrator connection using Docker service name
      ORCH_BASE_URL: ${ORCH_BASE_URL:-http://orchestrator:${ORCHESTRATOR_PORT:-8080}}
      # Redis connection using Docker service name
      REDIS_ADDR: ${REDIS_ADDR:-redis:6379}
      REDIS_PASSWORD: ${REDIS_PASSWORD:-}
      REDIS_DB: ${REDIS_DB:-0}
      # RabbitMQ connection using Docker service name
      RABBITMQ_URL: ${RABBITMQ_URL:-amqp://guest:guest@rabbitmq:5672/}
      RABBITMQ_QUEUE_NAME: ${RABBITMQ_QUEUE_NAME:-chat_messages}
      PRESENCE_TTL_SECONDS: ${PRESENCE_TTL_SECONDS:-60}
      # CORS allowed origins (comma-separated list)
      # Should include your frontend URL (e.g., http://3.17.68.221:3000 or https://yourdomain.com)
      CORS_ALLOWED_ORIGINS: ${CORS_ALLOWED_ORIGINS:-http://localhost:3000,http://localhost:3001}
    ports:
      - "8001:8001"
    depends_on:
      redis:
        condition: service_started
      rabbitmq:
        condition: service_healthy
      orchestrator:
        condition: service_started
    healthcheck:
      # No /health route shown, so do a TCP check
      test: ["CMD", "sh", "-c", "nc -z localhost 8001"]
      interval: 10s
      timeout: 5s
      retries: 5

  chat-consumer:                # background worker
    image: danlamgcm/chat-consumer:latest
    build:
      context: .
      dockerfile: ./chat-consumer/Dockerfile
    env_file:
      - ./.env
    environment:
      # RabbitMQ connection using Docker service name
      RABBITMQ_URL: ${RABBITMQ_URL:-amqp://guest:guest@rabbitmq:5672/}
      RABBITMQ_QUEUE_NAME: ${RABBITMQ_QUEUE_NAME:-chat_messages}
      # Redis connection using Docker service name
      REDIS_ADDR: ${REDIS_ADDR:-redis:6379}
      REDIS_PASSWORD: ${REDIS_PASSWORD:-}
      REDIS_DB: ${REDIS_DB:-0}
      # MongoDB Atlas connection string (required for chat-consumer)
      # Format: mongodb+srv://username:password@cluster.mongodb.net/chatdb?retryWrites=true&w=majority
      # Set MONGO_URI in .env file to your MongoDB Atlas connection string
      MONGO_URI: ${MONGO_URI}
    depends_on:
      rabbitmq:
        condition: service_healthy
      redis:
        condition: service_started
    restart: unless-stopped      # typical for background jobs

  frontend:
    image: danlamgcm/frontend:latest
    build:
      context: .
      dockerfile: ./frontend/Dockerfile
    container_name: frontend
    ports:
      - "3000:3000"
    environment:
      NODE_ENV: production
      # Set orchestrator URL for browser-side API calls
      # Uses exposed port on host machine since browser runs client-side
      # NEXT_PUBLIC_ORCHESTRATOR_URL should be set to full URL (e.g., http://3.17.68.221:8080)
      # If EXTERNAL_HOST is set, constructs URL from it; otherwise uses default IP
      # Update the default IP (3.17.68.221) to your AWS public IP or domain
      NEXT_PUBLIC_ORCHESTRATOR_URL: ${NEXT_PUBLIC_ORCHESTRATOR_URL:-http://${EXTERNAL_HOST:-3.17.68.221}:${ORCHESTRATOR_PORT:-8080}}
      # Events server WebSocket URL for browser-side connections
      # NEXT_PUBLIC_EVENTS_SERVER_URL should be set to full WebSocket URL (e.g., ws://3.17.68.221:8001/ws)
      # If EXTERNAL_HOST is set, constructs URL from it; otherwise uses default IP
      NEXT_PUBLIC_EVENTS_SERVER_URL: ${NEXT_PUBLIC_EVENTS_SERVER_URL:-ws://${EXTERNAL_HOST:-3.17.68.221}:8001/ws}
    depends_on:
      - orchestrator
      - events-server
    healthcheck:
      test: ["CMD", "wget", "-qO-", "http://localhost:3000/"]
      interval: 10s
      timeout: 5s
      retries: 5

volumes:
  pgdata:
    # Only used if you uncomment the local db service
